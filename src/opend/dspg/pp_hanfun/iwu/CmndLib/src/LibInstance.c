#include "LibInstance.h"
#include "CmndPubSub.h"
#include "CmndPacketDetector.h"
#include "Logger.h"
#include "CmndHibernationMng.h"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

static t_st_CmndLibData g_st_CmndLibInstance = {0};

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

#ifndef MULTI_THREAD
bool p_CmndLib_InitTransport( t_st_CmndLibData* pst_Instance, t_Handle hPort )
{
	pst_Instance->h_Port = hPort;
	return p_CmndPubSub_InitStatic( &pst_Instance->st_RxPubSub, pst_Instance->au8_RxPubSubBuffer, sizeof(pst_Instance->au8_RxPubSubBuffer) );
}

void p_CmndLib_DeinitTransport( INOUT t_st_CmndLibData* pst_Instance )
{
	ARGUSED( pst_Instance );
}
#else
	// LibInstanceMT.c should provide it's own implementation
#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

bool p_CmndLib_Init( t_Handle hUart )
{
	// Initialize CmndTransport structure
	return p_CmndLib_InitEx( &g_st_CmndLibInstance, hUart );
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

t_st_CmndLibData* p_CmndLib_Instance()
{
	return &g_st_CmndLibInstance;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

bool p_CmndLib_InitEx( t_st_CmndLibData* pst_Instance, t_Handle hUart )
{
	p_CmndLib_UserImpl_Event_Init();
	pst_Instance->b_Initialized = p_CmndLib_InitTransport( pst_Instance, hUart );
	memset(&pst_Instance->st_RecvData, 0, sizeof(t_stReceiveData));
	pst_Instance->st_HibernationMng.pf_WakeupCmnd = NULL;
	return pst_Instance->b_Initialized;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

void p_CmndLib_SupportCmndHibernation( t_st_CmndLibData* pst_Instance, t_pf_WakeupCmnd pf_WakeupCmnd, t_pf_OnCmndSleep pf_OnSleep )
{
	p_CmndHibernationMng_Configure( &pst_Instance->st_HibernationMng, pf_WakeupCmnd, pf_OnSleep );
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

void p_CmndLib_SetWriter( tpf_IoWrite pf_IoWrite )
{
	p_CmndLib_SetWriterEx( p_CmndLib_Instance(), pf_IoWrite );
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

void p_CmndLib_SetWriterEx( t_st_CmndLibData* pst_Instance, tpf_IoWrite pf_IoWrite )
{
	pst_Instance->pf_IoWrite = pf_IoWrite;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

void p_CmndLib_SetReader( tpf_IoRead pf_IoRead )
{
	p_CmndLib_SetReaderEx( p_CmndLib_Instance(), pf_IoRead );
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

void p_CmndLib_SetReaderEx( t_st_CmndLibData* pst_Instance, tpf_IoRead pf_IoRead )
{
	pst_Instance->pf_IoRead = pf_IoRead;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

void p_CmndLib_HandleChunk( const u8* pu8_Chunk, int length )
{
	p_CmndLib_HandleChunkEx( p_CmndLib_Instance(), pu8_Chunk, length );
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

#ifndef MULTI_THREAD
void p_CmndLib_HandleChunkEx( t_st_CmndLibData* pst_Instance, const u8* pu8_Chunk, int length )
{
	int i=0;

	if( !pst_Instance->b_Initialized )
	{
		return;
	}

	for(i=0; i<length; ++i)
	{
		bool haveMessage = p_hanCmndApi_HandleByte(&pst_Instance->st_RecvData, pu8_Chunk[i], &pst_Instance->st_RcvdMsg);

		if(haveMessage)
		{
			p_CmndApiPacket_Print(&pst_Instance->st_RecvData.packet, "RX");
			if ( !p_CmndPubSub_Publish( &pst_Instance->st_RxPubSub, &pst_Instance->st_RcvdMsg) )
			{
				LOG_ERROR( "Failed to publish message" );
			}
		}
	}
}

#endif

